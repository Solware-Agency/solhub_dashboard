# üìö Gu√≠a Completa de SolHub - Para Desarrolladores y Onboarding

Este documento es tu **fuente √∫nica de verdad** sobre SolHub. Est√° dise√±ado para que cualquier desarrollador nuevo pueda entender completamente el proyecto, sus procesos, configuraci√≥n y estado actual. Tambi√©n sirve como referencia para agregar nuevas features, roles y clientes.

---

## üéØ 1. ¬øQu√© es SolHub? (Visi√≥n General)

**SolHub** es una plataforma SaaS multi-tenant para la gesti√≥n integral de laboratorios cl√≠nicos en Venezuela. Permite que m√∫ltiples laboratorios compartan la misma infraestructura mientras mantienen un **aislamiento total de datos** mediante Row-Level Security (RLS).

### Caracter√≠sticas Principales
- **Multi-tenancy completo:** Cada laboratorio tiene su propio espacio aislado de datos
- **Branding personalizado:** Logo, colores y nombre personalizables por laboratorio
- **Feature flags:** Funcionalidades habilitadas/deshabilitadas por laboratorio
- **Configuraci√≥n granular:** Campos, acciones y m√≥dulos personalizables por laboratorio
- **Gesti√≥n de casos m√©dicos:** Registro, seguimiento y aprobaci√≥n de casos
- **Sistema de roles:** Owner, employee, residente, citotecno, patologo, medicowner, medico_tratante, enfermero, etc.
- **Auditor√≠a completa:** Historial de cambios y logs de todas las operaciones

### Arquitectura Multi-Tenant
- **Patr√≥n:** Shared Database, Shared Schema (todos los laboratorios usan las mismas tablas)
- **Aislamiento:** Columna `laboratory_id` en todas las tablas principales
- **Seguridad:** RLS (Row-Level Security) filtra autom√°ticamente por `laboratory_id`
- **Feature Flags:** Configuraci√≥n JSON por laboratorio en `laboratories.features`
- **Un solo codebase:** Todo en la rama `main`, features condicionadas por configuraci√≥n

---

## üèóÔ∏è 2. Stack Tecnol√≥gico y Estructura del Proyecto

### Stack Actual
- **Frontend:** React 18.2.0 + TypeScript, Vite 6.3.5 (Solhub_prod) / Next.js 15 (solhub_dashboard)
- **UI:** TailwindCSS 4.1.12, Radix UI, shadcn/ui
- **Estado:** TanStack Query, React Hook Form, Zod
- **Backend:** Supabase (PostgreSQL + RLS, Auth, Storage, Edge Functions)
- **Hosting:** Vercel (Frontend + Serverless Functions), Supabase Cloud (Database)
- **Package Manager:** pnpm (versi√≥n 10.17.1)

### Repositorios
1. **Solhub_prod** - Aplicaci√≥n principal SaaS multi-tenant
   - URL: `https://github.com/Solware-Agency/Solhub_prod`
   - Estado: ‚úÖ 100% MULTI-TENANT COMPLETADO
   - Estructura: `src/features/` (dominios), `src/shared/` (c√≥digo compartido)

2. **solhub_dashboard** - Panel administrativo para gestionar el SaaS
   - URL: `https://github.com/Solware-Agency/solhub_dashboard`
   - Estado: ‚úÖ 90% COMPLETADO
   - Estructura: `app/` (Next.js App Router), `components/`, `lib/`

---

## üé® 3. Estilos y Configuraci√≥n de Branding

### C√≥mo Funciona el Branding Din√°mico

**Concepto:** Cada laboratorio puede personalizar su apariencia (logo, colores, nombre) sin afectar a otros laboratorios.

**D√≥nde se almacena:** Tabla `laboratories.branding` (JSONB) en Supabase.

**Estructura del branding:**
```json
{
  "logo": "https://...",
  "name": "Laboratorio Conspat",
  "colors": {
    "primary": "#3B82F6",
    "secondary": "#10B981",
    "accent": "#F59E0B"
  },
  "icon": "üè•"
}
```

**C√≥mo se aplica:**
1. El frontend carga el branding del laboratorio desde `LaboratoryContext`
2. Se inyectan CSS Variables globales desde `src/styles/globals.css`
3. TailwindCSS usa estas variables para colorear componentes
4. El logo y nombre se muestran din√°micamente en la UI

**D√≥nde configurarlo:**
- **Dashboard:** `solhub_dashboard/app/(dashboard)/laboratories/[id]/edit/page.tsx`
- **Base de datos:** Tabla `laboratories`, campo `branding` (JSONB)

**Para agregar nuevos campos de branding:**
1. Actualizar el tipo TypeScript en `src/shared/types/` (Solhub_prod) o `lib/types/` (dashboard)
2. Agregar el campo al formulario de edici√≥n del laboratorio
3. Actualizar `globals.css` si necesitas nuevas CSS Variables
4. Usar el nuevo campo en los componentes que necesiten mostrarlo

---

## ‚öôÔ∏è 4. C√≥mo Agregar una Nueva Feature

### Proceso Completo (Paso a Paso)

**¬øQu√© es una Feature?** Una funcionalidad que puede estar habilitada o deshabilitada por laboratorio (ej: "Inmunohistoqu√≠mica", "Chat AI", "M√∫ltiples Sucursales").

#### Paso 1: Crear la Feature en el Cat√°logo
**D√≥nde:** Dashboard ‚Üí Features ‚Üí Cat√°logo ‚Üí Crear Nueva Feature

**Campos requeridos:**
- `key`: Identificador √∫nico (ej: `hasNewFeature`)
- `name`: Nombre legible (ej: "Nueva Funcionalidad")
- `description`: Descripci√≥n de qu√© hace
- `category`: Categor√≠a (ej: "modules", "integrations")
- `default_value`: Valor por defecto (normalmente `false`)
- `is_active`: Si est√° activa en el sistema

**Qu√© pasa autom√°ticamente:**
- La feature se agrega a TODOS los laboratorios con valor `false` (trigger autom√°tico)
- Los laboratorios existentes la reciben autom√°ticamente

#### Paso 2: Implementar la Feature en el C√≥digo
**En Solhub_prod:**
1. Crear componente/feature en `src/features/[nombre-feature]/`
2. Usar `<FeatureGuard featureKey="hasNewFeature">` para condicionar la UI
3. Verificar la feature con `useLaboratory()` hook:
   ```typescript
   const { laboratory } = useLaboratory();
   if (laboratory?.features?.hasNewFeature) {
     // Mostrar funcionalidad
   }
   ```

**En el Dashboard:**
- La feature ya aparece autom√°ticamente en la lista de features
- Los admins pueden habilitarla/deshabilitarla por laboratorio

#### Paso 3: Crear M√≥dulo Asociado (Opcional)
Si la feature requiere configuraci√≥n granular (campos, acciones, settings):
1. Ir a Dashboard ‚Üí M√≥dulos ‚Üí Crear M√≥dulo
2. Asociar con `feature_key` de la feature creada
3. Definir `structure` (JSONB) con campos, acciones y settings
4. La configuraci√≥n se sincroniza autom√°ticamente a todos los labs con la feature habilitada

#### Paso 4: Testing
- Verificar que la feature aparece en el dashboard
- Verificar que se puede habilitar/deshabilitar por laboratorio
- Verificar que la UI se muestra/oculta correctamente seg√∫n el estado
- Verificar que el aislamiento multi-tenant funciona (un lab no ve datos de otro)

**Checklist de Nueva Feature:**
- [ ] Feature creada en `feature_catalog`
- [ ] Feature agregada autom√°ticamente a todos los labs (verificar)
- [ ] C√≥digo implementado en `src/features/[nombre]/`
- [ ] `<FeatureGuard>` usado para condicionar UI
- [ ] M√≥dulo creado (si aplica) con configuraci√≥n granular
- [ ] Testing de habilitaci√≥n/deshabilitaci√≥n por laboratorio
- [ ] Testing de aislamiento multi-tenant

---

## üë• 5. C√≥mo Agregar un Nuevo Rol

### Proceso Completo (Paso a Paso)

**¬øQu√© es un Rol?** Define los permisos y capacidades de un usuario en el sistema (ej: "owner", "employee", "patologo").

#### Paso 1: Agregar el Rol a la Base de Datos
**D√≥nde:** Migraci√≥n SQL en `supabase/migrations/`

**Qu√© hacer:**
1. Actualizar el ENUM de roles en la tabla `profiles`:
   ```sql
   ALTER TYPE role_enum ADD VALUE 'nuevo_rol';
   ```
2. Si el rol tiene permisos especiales, actualizar las pol√≠ticas RLS correspondientes

#### Paso 2: Actualizar Tipos TypeScript
**D√≥nde:** `src/shared/types/types.ts` (Solhub_prod) o `lib/types/` (dashboard)

**Qu√© hacer:**
- Agregar el nuevo rol al tipo `Role` o `ProfileRole`

#### Paso 3: Configurar Roles Disponibles por Laboratorio
**D√≥nde:** Tabla `laboratories.available_roles` (array de texto)

**C√≥mo funciona:**
- Cada laboratorio puede tener diferentes roles disponibles
- Se configura en el dashboard al editar un laboratorio
- El campo `available_roles` es un array: `['owner', 'employee', 'nuevo_rol']`

#### Paso 4: Implementar L√≥gica de Permisos (Si Aplica)
**D√≥nde:** Componentes, servicios y pol√≠ticas RLS

**Qu√© hacer:**
- Si el rol tiene permisos especiales, actualizar:
  - Pol√≠ticas RLS en Supabase (si el rol puede ver/editar datos espec√≠ficos)
  - Validaciones en el frontend (componentes que verifican el rol)
  - Servicios que filtran por rol

**Ejemplo de validaci√≥n de rol:**
```typescript
const { profile } = useAuth();
if (profile?.role === 'nuevo_rol') {
  // Permitir acci√≥n
}
```

#### Paso 5: Actualizar UI (Si Aplica)
**D√≥nde:** Formularios de registro, selecci√≥n de roles, etc.

**Qu√© hacer:**
- Si el rol debe aparecer en formularios de registro, actualizar `RegisterForm.tsx`
- Si el rol debe aparecer en selecci√≥n de roles (dashboard), actualizar los componentes correspondientes

**Checklist de Nuevo Rol:**
- [ ] Rol agregado al ENUM en base de datos (migraci√≥n)
- [ ] Tipos TypeScript actualizados
- [ ] Rol agregado a `available_roles` de laboratorios que lo necesiten
- [ ] Pol√≠ticas RLS actualizadas (si aplica)
- [ ] Validaciones de permisos implementadas
- [ ] UI actualizada (formularios, selecciones)
- [ ] Testing de permisos y aislamiento

---

## üè¢ 6. Qu√© Hacer Cuando Llega un Nuevo Cliente (Laboratorio)

### Checklist Completo de Onboarding

#### Fase 1: Creaci√≥n del Laboratorio (Dashboard)
**D√≥nde:** Dashboard ‚Üí Laboratorios ‚Üí Crear Nuevo Laboratorio

**Pasos:**
1. **Crear el laboratorio:**
   - Nombre del laboratorio
   - Slug √∫nico (ej: "conspat", "vargas")
   - Estado: "active"

2. **Configurar Branding:**
   - Subir logo (URL o archivo)
   - Configurar colores (primary, secondary, accent)
   - Nombre para mostrar
   - √çcono (opcional)

3. **Configurar Features:**
   - Habilitar/deshabilitar features seg√∫n el plan del cliente
   - Las features se sincronizan autom√°ticamente con sus m√≥dulos

4. **Configurar M√≥dulos (Si aplica):**
   - Para cada feature habilitada, configurar campos, acciones y settings
   - Esto se hace autom√°ticamente al habilitar la feature, pero puedes ajustar valores por defecto

5. **Configurar Sucursales (Si aplica):**
   - Si `hasMultipleBranches` est√° habilitado, agregar sucursales en `config.branches`

6. **Configurar M√©todos de Pago:**
   - Agregar m√©todos de pago permitidos en `config.paymentMethods`

7. **Configurar Roles Disponibles:**
   - Definir qu√© roles puede tener este laboratorio en `available_roles`

8. **Configurar Sistema de C√≥digos:**
   - Configurar plantilla de c√≥digos en `config.codeTemplate`
   - Configurar mapeos de ex√°menes en `config.codeMappings`

#### Fase 2: Crear Usuario Owner
**D√≥nde:** Dashboard ‚Üí Usuarios o directamente en Supabase

**Pasos:**
1. Crear usuario en `auth.users` (Supabase Auth)
2. Crear perfil en `profiles` con:
   - `laboratory_id`: ID del laboratorio creado
   - `role`: "owner"
   - `estado`: "aprobado"
   - Email y datos del owner

#### Fase 3: Generar C√≥digos de Acceso
**D√≥nde:** Dashboard ‚Üí C√≥digos ‚Üí Crear C√≥digo

**Pasos:**
1. Seleccionar el laboratorio
2. Generar c√≥digo (ej: "CONSPAT2024")
3. Configurar:
   - `max_uses`: N√∫mero m√°ximo de usos (opcional)
   - `expires_at`: Fecha de expiraci√≥n (opcional)
   - `is_active`: true

4. Compartir c√≥digo con el owner para que lo distribuya a empleados

#### Fase 4: Verificaci√≥n
**Checklist de Verificaci√≥n:**
- [ ] Laboratorio creado con todos los datos
- [ ] Branding configurado y visible
- [ ] Features habilitadas seg√∫n plan
- [ ] M√≥dulos configurados correctamente
- [ ] Usuario owner creado y puede iniciar sesi√≥n
- [ ] C√≥digos de acceso generados
- [ ] Owner puede ver su laboratorio al iniciar sesi√≥n
- [ ] Aislamiento de datos verificado (no ve datos de otros labs)

#### Fase 5: Documentaci√≥n y Entrenamiento
- Proporcionar acceso al owner
- Explicar c√≥mo generar m√°s c√≥digos
- Explicar c√≥mo aprobar usuarios pendientes
- Proporcionar documentaci√≥n de uso (si existe)

---

## üöÄ 7. Onboarding para Nuevos Desarrolladores

### ¬øPor D√≥nde Empezar?

#### Paso 1: Entender la Arquitectura Multi-Tenant
**Concepto clave:** `laboratory_id` es el coraz√≥n del sistema. TODAS las operaciones deben filtrar por `laboratory_id`.

**Qu√© leer primero:**
- Esta secci√≥n del documento (secci√≥n 1)
- Secci√≥n 8 (Estado Actual del Sistema)
- Secci√≥n 9 (Reglas Cr√≠ticas de Desarrollo)

#### Paso 2: Configurar el Entorno
**Requisitos:**
- Node.js 18+
- pnpm 10.17.1
- Cuenta de Supabase (acceso al proyecto)
- Acceso a repositorios de GitHub (Solware-Agency)

**Pasos:**
1. Clonar repositorios:
   ```bash
   git clone https://github.com/Solware-Agency/Solhub_prod.git
   git clone https://github.com/Solware-Agency/solhub_dashboard.git
   ```

2. Instalar dependencias:
   ```bash
   cd Solhub_prod && pnpm install
   cd ../solhub_dashboard && pnpm install
   ```

3. Configurar variables de entorno:
   - Crear `.env.local` con credenciales de Supabase
   - Obtener credenciales del equipo

4. Ejecutar proyectos:
   ```bash
   # Solhub_prod
   cd Solhub_prod && pnpm dev

   # solhub_dashboard
   cd solhub_dashboard && pnpm dev
   ```

#### Paso 3: Explorar la Base de Datos
**D√≥nde:** Supabase Dashboard o usando MCP

**Qu√© explorar:**
1. Tabla `laboratories` - Ver laboratorios existentes
2. Tabla `profiles` - Ver usuarios y sus `laboratory_id`
3. Tabla `patients` - Ver c√≥mo se filtra por `laboratory_id`
4. Pol√≠ticas RLS - Entender c√≥mo funcionan

**Ejercicio pr√°ctico:**
- Crear un laboratorio de prueba desde el dashboard
- Ver c√≥mo se crea autom√°ticamente la configuraci√≥n
- Verificar que las features se agregan autom√°ticamente

#### Paso 4: Entender el Flujo de Datos
**Flujo t√≠pico:**
1. Usuario inicia sesi√≥n ‚Üí `LaboratoryContext` carga el laboratorio
2. Componente necesita datos ‚Üí Servicio filtra por `laboratory_id`
3. Datos se muestran ‚Üí Solo datos del laboratorio del usuario
4. Usuario crea/edita ‚Üí `laboratory_id` se asigna autom√°ticamente

**Archivos clave para entender:**
- `src/shared/contexts/LaboratoryContext.tsx` - Contexto del laboratorio
- `src/shared/services/supabase/` - Servicios que interact√∫an con Supabase
- `src/shared/components/FeatureGuard.tsx` - Componente para condicionar UI

#### Paso 5: Hacer tu Primera Modificaci√≥n
**Ejercicio sugerido:**
1. Agregar un campo nuevo a un formulario existente
2. Verificar que se guarda correctamente
3. Verificar que se filtra por `laboratory_id`
4. Verificar que otros laboratorios no ven ese dato

#### Paso 6: Leer C√≥digo Existente
**Archivos recomendados para leer:**
- `src/features/cases/components/MedicalFormContainer.tsx` - Ejemplo de formulario complejo
- `src/shared/services/supabase/cases/registration-service.ts` - Ejemplo de servicio
- `src/features/auth/components/RegisterForm.tsx` - Ejemplo de autenticaci√≥n

**Patrones a identificar:**
- C√≥mo se usa `useLaboratory()` hook
- C√≥mo se filtran queries por `laboratory_id`
- C√≥mo se usan `<FeatureGuard>` componentes
- C√≥mo se manejan errores y validaciones

### Recursos Adicionales
- Documentaci√≥n de Supabase: https://supabase.com/docs
- Documentaci√≥n de React Query: https://tanstack.com/query
- Documentaci√≥n de shadcn/ui: https://ui.shadcn.com

---

## üìä 8. Estado Actual del Sistema (Checkpoints)

### ‚úÖ Completado (100%)

#### Base de Datos
- ‚úÖ Sistema multi-tenant completamente implementado
- ‚úÖ Todas las tablas tienen `laboratory_id`
- ‚úÖ RLS policies configuradas en todas las tablas
- ‚úÖ Triggers autom√°ticos funcionando (c√≥digos, formateo, sincronizaci√≥n)
- ‚úÖ Funciones SQL para generaci√≥n de c√≥digos flexibles
- ‚úÖ Sistema de m√≥dulos con configuraci√≥n granular

#### Frontend (Solhub_prod)
- ‚úÖ Aislamiento total de datos por laboratorio
- ‚úÖ Branding din√°mico funcionando (logo, colores, nombre)
- ‚úÖ Feature flags operativos
- ‚úÖ Sistema de m√≥dulos con configuraci√≥n granular
- ‚úÖ Generador de tipos TypeScript funcional
- ‚úÖ Contexto de laboratorio (`LaboratoryContext`)

#### Dashboard (solhub_dashboard)
- ‚úÖ CRUD completo de laboratorios
- ‚úÖ Gesti√≥n completa de features (cat√°logo + asignaci√≥n)
- ‚úÖ Sistema de Configuraci√≥n Granular de M√≥dulos
- ‚úÖ Generador autom√°tico de tipos TypeScript
- ‚úÖ Creaci√≥n de c√≥digos de acceso

### ‚ö†Ô∏è Pendiente (Cr√≠tico)

#### Registro con C√≥digos en Solhub_prod (0% implementado)
**Qu√© falta:**
- Campo de c√≥digo en formulario de registro
- Servicio de validaci√≥n de c√≥digos
- Asignaci√≥n autom√°tica de `laboratory_id` al registrar
- Incremento de uso del c√≥digo
- Usuario en estado "pending approval"

**Por qu√© es cr√≠tico:**
- Sin esto, el flujo completo no funciona
- Los c√≥digos generados en el dashboard no se pueden usar
- Los empleados no pueden registrarse

**Tiempo estimado:** 2-3 d√≠as

### üü¢ Pendiente (Opcional)

#### Dashboard
- Vista global de usuarios (30% - falta gesti√≥n avanzada)
- Gesti√≥n de c√≥digos (60% - falta edici√≥n, estad√≠sticas, exportar)

#### Frontend Principal
- Hooks `useModuleConfig` y `useModuleField` para usar configuraci√≥n granular
- Mejoras de UX (gr√°ficas, animaciones, dise√±o pulido)

---

## üóÑÔ∏è 9. Base de Datos Supabase - Estructura Completa Verificada

### Proyecto
- **Project ID:** `sbqepjsxnqtldyvlntqk`
- **URL:** `https://sbqepjsxnqtldyvlntqk.supabase.co`
- **PostgreSQL:** 17.4.1
- **Migraciones:** 115 aplicadas
- **Proyecto:** Forms conspat (SolHub)

### Tablas Principales (Verificadas en Supabase)

#### Tablas Multi-Tenant (Tienen `laboratory_id` y RLS habilitado)
1. **`patients`** - Pacientes/asegurados del laboratorio
   - Campos principales: `id`, `cedula`, `nombre`, `edad`, `telefono`, `email`, `gender`, `version`, `laboratory_id`
   - Constraint √∫nico: `(cedula, laboratory_id)` - permite duplicados entre labs
   - √çndices: `idx_patients_laboratory`, `idx_patients_cedula`, `idx_patients_cedula_lower`, `idx_patients_nombre_lower`, `idx_patients_lab_created`, `unique_cedula_per_laboratory`

2. **`medical_records_clean`** - Casos/registros m√©dicos
   - Campos principales: `id`, `code`, `exam_type`, `origin`, `treating_doctor`, `sample_type`, `number_of_samples`, `date`, `patient_id`, `laboratory_id`
   - Campos de pago: `payment_method_1-4`, `payment_amount_1-4`, `payment_reference_1-4`, `total_amount`, `exchange_rate`, `payment_status`, `remaining`
   - Campos de documentos: `attachment_url`, `googledocs_url`, `informepdf_url`, `informe_qr`, `token`, `pdf_en_ready`
   - Campos de aprobaci√≥n: `doc_aprobado`, `cito_status`, `email_sent`
   - Auditor√≠a: `created_by`, `created_by_display_name`, `generated_by`, `generated_by_display_name`, `generated_at`
   - Constraint √∫nico: `(code, laboratory_id)`
   - √çndices: M√∫ltiples √≠ndices en `laboratory_id`, `code`, `patient_id`, `created_at`, `payment_status`, `exam_type`, `branch`, `doc_aprobado`, `cito_status`

3. **`profiles`** - Perfiles de usuarios (vinculados a un laboratorio)
   - Campos principales: `id` (FK ‚Üí auth.users.id), `email`, `email_lower`, `role`, `estado`, `display_name`, `phone`, `assigned_branch`, `laboratory_id`
   - Roles disponibles: `owner`, `employee`, `admin`, `residente`, `citotecno`, `patologo`, `medicowner`, `medico_tratante`, `enfermero`, `prueba`, `call_center`, `imagenologia`
   - Estados: `pendiente`, `aprobado`
   - √çndices: `idx_profiles_laboratory`, `idx_profiles_email`, `idx_profiles_role`, `idx_profiles_estado`, `idx_profiles_lab_role`, `profiles_email_key`, `profiles_email_lower_uq`

4. **`triaje_records`** - Registros de triaje m√©dico
   - Campos principales: `id`, `patient_id`, `case_id`, `laboratory_id`, `measurement_date`
   - Mediciones f√≠sicas: `height_cm`, `weight_kg`, `bmi`, `blood_pressure`, `heart_rate`, `respiratory_rate`, `oxygen_saturation`, `temperature_celsius`
   - H√°bitos: `alcohol` (enum habit_level_type), `tabaco` (numeric - paquetes-a√±o), `cafe` (integer - tazas/d√≠a)
   - Historial m√©dico: `reason`, `personal_background`, `family_history`, `psychobiological_habits`, `examen_fisico`, `comment`
   - Constraint √∫nico: `(case_id)` - un caso puede tener m√°ximo un triaje
   - √çndices: `idx_triage_records_laboratory_id`, `idx_triage_records_patient_id`, `idx_triaje_records_case_id`, `idx_triage_records_measurement_date`, `idx_triage_records_patient_date`, `idx_triaje_records_tabaco`, `idx_triaje_records_cafe`

5. **`change_logs`** - Historial de cambios (auditor√≠a)
   - Campos principales: `id`, `medical_record_id`, `patient_id`, `user_id`, `user_email`, `user_display_name`, `field_name`, `field_label`, `old_value`, `new_value`, `entity_type`, `deleted_record_info`, `changed_at`, `laboratory_id`
   - √çndices: `idx_change_logs_laboratory`, `idx_change_logs_medical_record_id`, `idx_change_logs_patient_id`, `idx_change_logs_user_id`, `idx_change_logs_changed_at`, `idx_change_logs_entity_type`

6. **`immuno_requests`** - Solicitudes de inmunohistoqu√≠mica
   - Campos principales: `id`, `case_id` (UNIQUE), `inmunorreacciones`, `n_reacciones`, `precio_unitario`, `total`, `pagado`, `laboratory_id`
   - √çndices: `idx_immuno_requests_case_id`, `idx_immuno_requests_laboratory`, `idx_immuno_requests_pagado`, `idx_immuno_requests_created_at`, `immuno_requests_case_id_key`

7. **`user_settings`** - Configuraciones de usuario
   - Campos principales: `id` (FK ‚Üí auth.users.id), `session_timeout`, `laboratory_id`
   - √çndices: `idx_user_settings_laboratory`

#### Tablas Globales (No tienen `laboratory_id`)
1. **`laboratories`** - Cat√°logo de laboratorios (configuraci√≥n, branding, features)
   - Campos principales: `id`, `slug` (UNIQUE), `name`, `status` (enum: active, inactive, trial), `features` (JSONB), `branding` (JSONB), `config` (JSONB), `available_roles` (text[])
   - √çndices: `idx_laboratories_slug`, `idx_laboratories_status`, `laboratories_slug_key`

2. **`feature_catalog`** - Cat√°logo maestro de features del sistema
   - Campos principales: `id`, `key` (UNIQUE), `name`, `description`, `category` (enum: core, premium, addon), `required_plan` (enum: free, basic, pro, enterprise), `icon`, `is_active`, `default_value`, `component_path`
   - RLS: Deshabilitado (lectura p√∫blica)
   - √çndices: `idx_feature_catalog_key`, `idx_feature_catalog_active`, `feature_catalog_key_key`

3. **`module_catalog`** - Cat√°logo de m√≥dulos (configuraci√≥n granular)
   - Campos principales: `id`, `feature_key` (UNIQUE, FK ‚Üí feature_catalog.key), `module_name`, `structure` (JSONB), `is_active`
   - RLS: Habilitado (lectura p√∫blica)
   - √çndices: `idx_module_catalog_feature_key`, `idx_module_catalog_active`, `module_catalog_feature_key_key`

4. **`laboratory_codes`** - C√≥digos de acceso para registro
   - Campos principales: `id`, `laboratory_id` (FK ‚Üí laboratories.id), `code` (UNIQUE), `is_active`, `max_uses`, `current_uses`, `expires_at`, `created_by`
   - √çndices: `idx_lab_codes_laboratory`, `idx_lab_codes_code`, `idx_lab_codes_active`, `laboratory_codes_code_key`

#### Vistas
1. **`laboratory_stats`** - Vista agregada con estad√≠sticas por laboratorio
   - Campos: `id`, `slug`, `name`, `status`, `total_patients`, `total_medical_records`, `total_users`, `last_record_date`
   - Agrupa datos de `laboratories`, `patients`, `medical_records_clean`, `profiles`

### Tipos ENUM Definidos

1. **`cito_status_type`**: `positivo`, `negativo`
2. **`doc_aprobado_status`**: `faltante`, `pendiente`, `aprobado`, `rechazado`
3. **`exam_type`**: `Biopsia`, `Inmunohistoqu√≠mica`, `Citolog√≠a`
4. **`gender_type`**: `Masculino`, `Femenino`
5. **`habit_level_type`**: `muy alta`, `alta`, `media`, `baja`, `muy baja`, `No`
6. **`payment_status_type`**: `Incompleto`, `Pagado`

### Funciones SQL (Lista Completa Verificada)

#### Generaci√≥n de C√≥digos
1. **`generate_medical_record_code_flexible(exam_type_input, case_date_input, laboratory_id_input)`** ‚≠ê
   - Genera c√≥digos √∫nicos por laboratorio seg√∫n plantilla configurable
   - Soporta placeholders: `{examCode}`, `{type}`, `{counter:N}`, `{month}`, `{year:2}`, `{year:4}`, `{day:2}`
   - Usa `pg_advisory_xact_lock` para evitar condiciones de carrera

2. **`generate_medical_record_code_from_table(exam_type_input, case_date_input, laboratory_id_input)`**
   - Funci√≥n principal que detecta formato del laboratorio
   - Si `config.codeFormat.type="custom"` usa `generate_spt_custom_code()`
   - Si no, usa formato Conspat: `[tipo][a√±o][contador:3d][mes]`

3. **`generate_spt_custom_code(exam_type_input, consulta_input, case_date_input, laboratory_id_input, laboratory_config)`**
   - Genera c√≥digos formato SPT: `[C√ìDIGO][0001][MES][A√ëO]`
   - Ejemplo: `CI0001K25`

4. **`get_exam_code_from_mapping(exam_type_input, code_mappings)`**
   - Busca c√≥digo de examen en codeMappings JSONB
   - B√∫squeda case-insensitive y parcial

5. **`get_exam_type_number(exam_type_input)`**
   - Convierte tipo de examen a n√∫mero: 1=citolog√≠a, 2=biopsia, 3=inmunohistoqu√≠mica

6. **`preview_medical_record_code(exam_type_input, case_date_input, laboratory_id_input)`**
   - Genera preview del c√≥digo antes de crear el caso

#### Configuraci√≥n de M√≥dulos
7. **`build_module_config_from_structure(module_structure)`** ‚≠ê
   - Construye configuraci√≥n de m√≥dulo desde estructura base
   - Define `{enabled, required}` para campos, `boolean` para acciones, valores por defecto para settings

8. **`sync_new_field_to_all_labs(p_feature_key, p_field_name, p_field_config)`**
   - Sincroniza nuevo campo a todos los labs con la feature habilitada
   - Establece `enabled: false` por defecto

9. **`remove_field_from_all_labs(p_feature_key, p_field_name)`**
   - Elimina campo de todos los labs con la feature habilitada

10. **`sync_missing_module_configs()`**
    - Sincroniza configuraciones faltantes de m√≥dulos a laboratorios

#### Formateo y Validaci√≥n
11. **`format_name(input_name)`**
    - Formatea nombres (capitaliza palabras, elimina espacios extra)

12. **`email_exists_auth(p_email)`**
    - Verifica si un email existe en `auth.users`

#### Autenticaci√≥n y Usuarios
13. **`handle_new_user()`** ‚≠ê (Trigger Function)
    - Crea perfil autom√°ticamente cuando se registra un nuevo usuario
    - Lee `laboratory_id` y `role` de `raw_user_meta_data`
    - Asigna `laboratory_id` desde c√≥digo de laboratorio
    - Estado inicial: `pendiente`

14. **`get_user_laboratory_id()`**
    - Retorna `laboratory_id` del usuario autenticado
    - Usado en pol√≠ticas RLS y queries

15. **`get_user_role()`**
    - Retorna `role` del usuario autenticado
    - Usado en validaciones y RLS policies

16. **`is_authenticated_superadmin()`**
    - Verifica si el usuario autenticado es superadmin activo
    - SECURITY DEFINER evita recursi√≥n en RLS

#### C√°lculos Autom√°ticos
17. **`calculate_bmi()`** (Trigger Function)
    - Calcula autom√°ticamente BMI desde altura y peso

18. **`actualizar_pdf_en_ready_medical()`**
    - Actualiza `pdf_en_ready` a `TRUE` si `informe_qr` tiene contenido

#### Auditor√≠a
19. **`get_all_change_logs_with_deleted()`**
    - Obtiene todos los logs incluyendo registros eliminados
    - Incluye informaci√≥n de caso si existe

20. **`save_change_log_for_deleted_record(p_medical_record_id, p_user_id, p_user_email, p_deleted_record_info)`**
    - Guarda log de eliminaci√≥n de registro

#### Testing
21. **`test_multitenant_isolation()`**
    - Verifica que el aislamiento de datos funciona correctamente

### Triggers Autom√°ticos (Lista Completa Verificada)

#### En `medical_records_clean`
1. **`trg_set_medical_record_code`** (BEFORE INSERT) - Genera c√≥digo usando `set_medical_record_code()`
2. **`trigger_actualizar_pdf_en_ready_medical`** (BEFORE INSERT/UPDATE) - Actualiza `pdf_en_ready`
3. **`trigger_format_medical_record_names`** (BEFORE INSERT/UPDATE) - Formatea nombres de m√©dicos
4. **`trigger_validate_laboratory_id_medical_records`** (BEFORE INSERT) - Valida y asigna `laboratory_id`
5. **`trg_doc_aprobado_transition`** (BEFORE UPDATE) - Aplica transiciones v√°lidas de `doc_aprobado`
6. **`update_medical_records_clean_updated_at`** (BEFORE UPDATE) - Actualiza timestamp

#### En `patients`
7. **`trigger_format_patient_names`** (BEFORE INSERT/UPDATE) - Formatea nombres de pacientes
8. **`trigger_validate_laboratory_id_patients`** (BEFORE INSERT) - Valida y asigna `laboratory_id`
9. **`update_patients_updated_at`** (BEFORE UPDATE) - Actualiza timestamp

#### En `profiles`
10. **`profiles_email_lower_tr`** (BEFORE INSERT/UPDATE) - Establece `email_lower`
11. **`sync_display_name_to_auth_trigger`** (AFTER UPDATE) - Sincroniza `display_name` a auth
12. **`update_profiles_updated_at`** (BEFORE UPDATE) - Actualiza timestamp

#### En `triaje_records`
13. **`calculate_bmi_trigger`** (BEFORE INSERT/UPDATE) - Calcula BMI autom√°ticamente
14. **`update_triage_records_timestamp`** (BEFORE UPDATE) - Actualiza timestamp

#### En `change_logs`
15. **`trigger_validate_laboratory_id_change_logs`** (BEFORE INSERT) - Valida y asigna `laboratory_id`
16. **`update_change_logs_created_at`** (BEFORE INSERT) - Actualiza timestamp

#### En `laboratories`
17. **`before_insert_laboratory`** (BEFORE INSERT) - Asigna valores por defecto
18. **`on_feature_enable_sync_module`** (BEFORE UPDATE) - Sincroniza m√≥dulo al habilitar feature
19. **`on_lab_insert_apply_module_config`** (BEFORE INSERT) - Aplica configuraci√≥n de m√≥dulos
20. **`trigger_update_laboratories_updated_at`** (BEFORE UPDATE) - Actualiza timestamp

#### En `feature_catalog`
21. **`on_feature_created_sync_labs`** (AFTER INSERT) - Sincroniza nueva feature a todos los labs
22. **`trigger_update_feature_catalog_updated_at`** (BEFORE UPDATE) - Actualiza timestamp

#### En `module_catalog`
23. **`before_insert_module_validate_feature`** (BEFORE INSERT/UPDATE) - Valida que feature existe
24. **`on_module_update_sync_fields`** (AFTER UPDATE) - Sincroniza nuevos campos a todos los labs

#### En `immuno_requests`
25. **`update_immuno_requests_updated_at`** (BEFORE UPDATE) - Actualiza timestamp

### Pol√≠ticas RLS (Lista Completa Verificada)

#### Patr√≥n General
Todas las pol√≠ticas RLS filtran por `laboratory_id` del usuario autenticado usando:
```sql
laboratory_id = (SELECT laboratory_id FROM profiles WHERE id = auth.uid())
```

#### Pol√≠ticas por Tabla

**`patients`** (4 pol√≠ticas):
- SELECT: Usuarios ven solo pacientes de su laboratorio
- INSERT: Usuarios insertan solo en su laboratorio
- UPDATE: Usuarios actualizan solo pacientes de su laboratorio
- DELETE: Usuarios eliminan solo pacientes de su laboratorio
- Lectura p√∫blica: Pol√≠tica adicional permite lectura an√≥nima

**`medical_records_clean`** (12 pol√≠ticas):
- SELECT: M√∫ltiples pol√≠ticas (por laboratorio, por branch, owners, lectura p√∫blica con token)
- INSERT: Por laboratorio y por branch
- UPDATE: Por laboratorio y por branch
- DELETE: Owners y usuarios por branch
- Lectura p√∫blica: Pol√≠tica para lectura an√≥nima y con token

**`profiles`** (6 pol√≠ticas):
- SELECT: Usuarios ven perfiles de su laboratorio
- INSERT: Usuarios insertan solo su propio perfil
- UPDATE: Usuarios actualizan su perfil o owners/admins actualizan perfiles de su lab
- DELETE: Solo owners pueden eliminar

**`change_logs`** (6 pol√≠ticas):
- SELECT: 2 pol√≠ticas (una permite lectura general, otra filtra por laboratorio)
- INSERT: 2 pol√≠ticas (una valida `user_id`, otra valida `laboratory_id`)
- UPDATE: Usuarios actualizan logs de su laboratorio
- DELETE: Usuarios eliminan logs de su laboratorio

**`immuno_requests`** (7 pol√≠ticas):
- SELECT: M√∫ltiples pol√≠ticas (lectura general y filtrada por laboratorio)
- INSERT: Por laboratorio y general
- UPDATE: Por laboratorio y general
- DELETE: Owners y usuarios por laboratorio

**`triaje_records`** (4 pol√≠ticas):
- SELECT: Usuarios ven solo triajes de su laboratorio
- INSERT: Usuarios insertan solo en su laboratorio (valida que `patient_id` pertenezca al lab)
- UPDATE: Usuarios actualizan solo triajes de su laboratorio
- DELETE: Usuarios eliminan solo triajes de su laboratorio

**`user_settings`** (4 pol√≠ticas):
- SELECT: Usuarios leen solo su configuraci√≥n
- INSERT: Usuarios insertan solo su configuraci√≥n
- UPDATE: Usuarios actualizan solo su configuraci√≥n
- DELETE: Usuarios eliminan solo su configuraci√≥n

**`laboratories`** (5 pol√≠ticas):
- SELECT: Lectura p√∫blica para todos
- INSERT: Bloqueado para anon_key
- UPDATE: Permitido para anon/authenticated y service_role
- DELETE: Bloqueado para anon_key

**`laboratory_codes`** (5 pol√≠ticas):
- SELECT: 2 pol√≠ticas (lectura de c√≥digos activos para registro p√∫blico)
- INSERT: Bloqueado para anon_key
- UPDATE: Bloqueado para anon_key
- DELETE: Bloqueado para anon_key

**`feature_catalog`** (RLS deshabilitado):
- Lectura p√∫blica sin restricciones

**`module_catalog`** (2 pol√≠ticas):
- SELECT: 2 pol√≠ticas (lectura general y lectura de m√≥dulos activos)
- ALL: Pol√≠tica general permite todas las operaciones

### √çndices de Performance (Principales)

#### √çndices en `laboratory_id` (Multi-tenant)
- Todas las tablas multi-tenant tienen √≠ndice en `laboratory_id`
- √çndices compuestos: `(laboratory_id, created_at)`, `(laboratory_id, payment_status)`, etc.

#### √çndices de B√∫squeda
- `idx_patients_cedula_lower`, `idx_patients_nombre_lower` - B√∫squeda case-insensitive
- `idx_medical_records_treating_doctor_lower` - B√∫squeda de m√©dicos
- `idx_triaje_records_tabaco`, `idx_triaje_records_cafe` - B√∫squeda por h√°bitos

#### √çndices √önicos
- `unique_cedula_per_laboratory` - C√©dula √∫nica por laboratorio
- `medical_records_clean_code_laboratory_unique` - C√≥digo √∫nico por laboratorio
- `idx_triaje_records_case_unique` - Un triaje por caso

### Nota Importante sobre `admin_users`
**La tabla `admin_users` NO existe en la base de datos actual.** Fue mencionada en documentaci√≥n anterior pero no est√° implementada. El sistema de administraci√≥n del dashboard actualmente funciona sin esta tabla, usando pol√≠ticas RLS especiales en `laboratories` y `laboratory_codes` que permiten operaciones desde el dashboard.

---

## üîÑ 10. Integraci√≥n con n8n (Automatizaciones)

### ¬øQu√© es n8n?
n8n es una plataforma de automatizaci√≥n que extiende las funcionalidades de SolHub conect√°ndolo con servicios externos (Google Docs, Google Drive, emails, etc.).

### Flujos Identificados y Verificados

#### "Encabezados SPT" (ID: `QuTpwzyUBw29ZbZN`)
**Qu√© hace:** Genera y actualiza documentos (informes m√©dicos) usando datos de Supabase y Google Docs/Drive para el cliente SPT.

**Tablas de Supabase que usa:**
- `patients` - Obtiene informaci√≥n del paciente
- `medical_records_clean` - Actualiza URLs de documentos (`googledocs_url`)

**Nodos del flujo:**
1. `Webhook` - Activa el flujo cuando se requiere generar encabezado
2. `Get a row` (Supabase) - Obtiene datos de `patients` desde Supabase
3. `Update a document` (Google Docs) - Actualiza plantilla de documento con datos del paciente
4. `If` - L√≥gica condicional dentro del flujo
5. `Actualizar URL de Docs` (Supabase) - Actualiza `googledocs_url` en `medical_records_clean`
6. `Edit Fields3` (Set) - Transforma campos de datos
7. `Crear encabezado` (Google Drive) - Crea encabezado de documento en Google Drive

**Flujo detallado:**
1. Webhook activa el flujo (probablemente desde SolHub cuando se crea/actualiza un caso)
2. n8n obtiene datos de `patients` desde Supabase (filtrando por `laboratory_id` del cliente SPT)
3. n8n actualiza plantilla en Google Docs con datos del paciente
4. n8n crea encabezado en Google Drive
5. n8n actualiza `googledocs_url` en `medical_records_clean` en Supabase

#### "SPT - PDF" (ID: `vLtR1C7AIAcvlo4f`)
**Qu√© hace:** Automatiza la generaci√≥n, carga a Supabase Storage y actualizaci√≥n de archivos PDF con c√≥digos QR, interactuando con las tablas `patients` y `medical_records_clean` para el cliente SPT.

**Tablas de Supabase que usa:**
- `patients` - Obtiene informaci√≥n del paciente
- `medical_records_clean` - Obtiene datos del caso y actualiza URLs de PDF (`informepdf_url`, `informe_qr`, `pdf_en_ready`)

**Nodos del flujo:**
1. `Webhook` - Activa el flujo cuando se requiere generar PDF
2. `Get a document` (Google Docs) - Obtiene documento de Google Docs
3. `Download file` (Google Drive) - Descarga archivo de Google Drive
4. `Obtener URL` (HTTP Request) - Obtiene URL del documento
5. `Generate QR` (HTTP Request) - Genera c√≥digo QR mediante servicio externo
6. `Code` (Code) - Ejecuta l√≥gica personalizada para procesar datos
7. `Build Download URL` (Set) - Construye URL de descarga
8. `Doc ID` (Set) - Establece ID de documento
9. `Cargar PDf en bucket` (HTTP Request) - Carga PDF a Supabase Storage
10. `Update a row` (Supabase) - Actualiza `medical_records_clean` con URLs del PDF
11. `If` - L√≥gica condicional
12. `(borrar + insertar)` (HTTP Request) - Operaci√≥n HTTP con borrar e insertar
13. `(solo insertar)` (HTTP Request) - Operaci√≥n HTTP solo insertar

**Flujo detallado:**
1. Webhook activa el flujo (probablemente cuando un caso es aprobado o se requiere PDF)
2. n8n obtiene datos de `patients` y `medical_records_clean` desde Supabase (filtrando por `laboratory_id` del cliente SPT)
3. n8n descarga documento de Google Drive usando `googledocs_url`
4. n8n genera c√≥digo QR con datos del caso (probablemente usando `code` o `token` del caso)
5. n8n genera PDF con c√≥digo QR incrustado
6. n8n carga PDF a Supabase Storage (bucket de archivos)
7. n8n actualiza `medical_records_clean` con:
   - `informepdf_url` - URL del PDF generado
   - `informe_qr` - URL o contenido del informe con QR
   - `pdf_en_ready` - `TRUE` cuando el PDF est√° listo

### Campos de Supabase Usados por n8n

#### En `patients`
- `id`, `cedula`, `nombre`, `edad`, `telefono`, `email`, `gender` - Datos del paciente para documentos

#### En `medical_records_clean`
- `id`, `code` - Identificaci√≥n del caso
- `patient_id` - Relaci√≥n con paciente
- `googledocs_url` - URL del documento editable (usado por "Encabezados SPT")
- `informepdf_url` - URL del PDF final (actualizado por "SPT - PDF")
- `informe_qr` - URL del informe con QR (actualizado por "SPT - PDF")
- `pdf_en_ready` - Estado de disponibilidad del PDF (actualizado por "SPT - PDF")
- `token` - Token de verificaci√≥n para acceso a informes
- `laboratory_id` - **CR√çTICO:** Debe filtrarse en todas las consultas

### Reglas Cr√≠ticas para n8n

1. **SIEMPRE filtrar por `laboratory_id`** en todas las consultas a Supabase desde n8n
   - Ejemplo: `SELECT * FROM patients WHERE laboratory_id = 'uuid-del-cliente'`
   - Esto garantiza el aislamiento de datos multi-tenant

2. **Validar `laboratory_id` en webhooks**
   - El webhook debe incluir `laboratory_id` en el payload
   - Verificar que el `laboratory_id` existe en la tabla `laboratories`

3. **Usar campos correctos para actualizaciones**
   - `googledocs_url` - Para documentos editables en Google Docs
   - `informepdf_url` - Para PDFs finales
   - `informe_qr` - Para informes con QR
   - `pdf_en_ready` - Para indicar que el PDF est√° listo

4. **Manejar errores de Supabase**
   - Si una actualizaci√≥n falla, no continuar con el flujo
   - Loggear errores para debugging

### Integraci√≥n Futura con n8n

Para agregar nuevos flujos de n8n:
1. Identificar qu√© tablas de Supabase necesita el flujo
2. Asegurar que todas las consultas filtren por `laboratory_id`
3. Documentar qu√© campos se leen y escriben
4. Agregar validaciones de `laboratory_id` en webhooks
5. Probar el flujo con m√∫ltiples laboratorios para verificar aislamiento

---

## üö® 11. Reglas Cr√≠ticas de Desarrollo (NON-NEGOTIABLE)

### Seguridad Multi-Tenant
1. **NUNCA** hacer queries sin filtrar por `laboratory_id`
2. **SIEMPRE** validar que RLS est√° habilitado en tablas nuevas
3. **SIEMPRE** verificar que el usuario pertenece al laboratorio antes de operaciones cr√≠ticas
4. **LOGUEAR** todos los accesos a datos sensibles en `change_logs`
5. **TESTEAR** exhaustivamente el aislamiento de datos entre laboratorios

### C√≥digo
1. Usar `<FeatureGuard>` para condicionar UI por features
2. Usar `useLaboratory()` hook para acceder al laboratorio actual
3. **NUNCA** hardcodear configuraci√≥n de laboratorios en c√≥digo
4. Mantener configuraci√≥n en tabla `laboratories` de Supabase
5. Todo servicio de Supabase **DEBE** incluir `.eq('laboratory_id', laboratoryId)`
6. Al insertar datos, **SIEMPRE** incluir `laboratory_id`

### Base de Datos
1. Toda tabla nueva **DEBE** tener `laboratory_id uuid references laboratories(id)`
2. Crear √≠ndice en `laboratory_id` para performance
3. Configurar RLS policies para filtrar por `laboratory_id`
4. Backups regulares con `pg_dump`

---

## üìã 12. Procesos de Trabajo Comunes

### C√≥mo Agregar un Campo Nuevo a un Formulario Existente

1. **Actualizar la tabla en Supabase:**
   - Crear migraci√≥n SQL agregando la columna
   - Agregar `laboratory_id` si es una tabla nueva
   - Crear √≠ndice si es necesario

2. **Actualizar tipos TypeScript:**
   - Regenerar tipos desde Supabase o actualizar manualmente
   - Actualizar interfaces en `src/shared/types/`

3. **Actualizar el formulario:**
   - Agregar campo al componente del formulario
   - Agregar validaci√≥n con Zod (si aplica)
   - Actualizar servicio que guarda los datos

4. **Testing:**
   - Verificar que se guarda correctamente
   - Verificar que se filtra por `laboratory_id`
   - Verificar que otros labs no ven el dato

### C√≥mo Agregar una Nueva Tabla Multi-Tenant

1. **Crear migraci√≥n SQL:**
   ```sql
   CREATE TABLE nueva_tabla (
     id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
     laboratory_id uuid NOT NULL REFERENCES laboratories(id),
     -- otros campos
     created_at timestamptz DEFAULT now()
   );

   CREATE INDEX idx_nueva_tabla_laboratory ON nueva_tabla(laboratory_id);
   ```

2. **Configurar RLS:**
   - Habilitar RLS en la tabla
   - Crear pol√≠ticas SELECT, INSERT, UPDATE, DELETE
   - Todas deben filtrar por `laboratory_id`

3. **Crear trigger para asignar `laboratory_id`:**
   - Trigger BEFORE INSERT que asigna `laboratory_id` desde el perfil del usuario

4. **Actualizar tipos TypeScript:**
   - Regenerar tipos desde Supabase

5. **Crear servicio en el frontend:**
   - Crear servicio en `src/shared/services/supabase/[nombre]/`
   - Todos los queries deben filtrar por `laboratory_id`

6. **Testing:**
   - Verificar que RLS funciona correctamente
   - Verificar que el trigger asigna `laboratory_id`
   - Verificar aislamiento entre laboratorios

---

## üîß 13. Configuraci√≥n MCP (Model Context Protocol)

### Supabase MCP
- **Project ID:** `sbqepjsxnqtldyvlntqk`
- **Estado:** ACTIVE_HEALTHY
- **Token:** Configurado en `C:\Users\andre\.cursor\mcp.json`

### GitHub MCP
- **Organizaci√≥n:** Solware-Agency
- **Repositorios:** Todos los repos de Solware-Agency accesibles

### n8n MCP
- Flujos identificados: "Encabezados SPT", "SPT - PDF"
- Se puede usar para ejecutar y consultar flujos de trabajo

---

## üìù 14. Notas Importantes

- **Package Manager:** Usar `pnpm` por defecto (versi√≥n 10.17.1)
- **Idioma de respuestas:** Espa√±ol
- **Proyecto Supabase principal:** Forms conspat (`sbqepjsxnqtldyvlntqk`)
- **Repositorio principal:** `Solhub_prod`
- **Dashboard administrativo:** `solhub_dashboard`

### Referencias
- Planes de implementaci√≥n en `.cursor/plans/*.plan.md`
- Documentaci√≥n del Proyecto Inntegras (m√≥dulo aseguradoras)

---

**√öltima actualizaci√≥n:** 2025-12-12
**Versi√≥n del documento:** 2.0 (Orientado a procesos y onboarding)